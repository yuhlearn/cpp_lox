#! /usr/bin/env python3

def write_to_file(full_path, content):
    try:
        out_file = open(full_path, mode='w')
    except Exception:
        print("failed to open " + full_path)
        exit(0)
    out_file.write(content)

def split_lines(lines):
    line_dict = dict()
    for line in lines:
        spl = line.split('=')
        obj = spl[0].strip()
        membs = spl[1].split(',')
        line_dict[obj] = [memb.strip().split() for memb in membs]
    return line_dict

def gen_code(base_class, line_dict, includes):
    classes = sorted(list(line_dict.keys()))

    code = ""
    code += "#ifndef _" + base_class.upper() + "_HPP\n"
    code += "#define _" + base_class.upper() + "_HPP\n\n"
    for incl in includes:
            code += "#include <" + incl + ">\n"
    code += "\nnamespace Lox\n{\n"
    
    # generate class declarations, eg: "class Assign;" 
    for clas in classes:
        code += "\tclass " + clas + ";\n"
    code += "\n"

    # generate visitor interface
    code += "\tclass " + base_class + "Visitor\n\t{\n\tpublic:\n"
    code += "\t\tvirtual ~" + base_class + "Visitor(void) {}\n" 
    for clas in classes:
        # member functions eg: "virtual boost::any visitAssignExpr(const std::shared_ptr<Assign> expr) const = 0;"
        code += "\t\tvirtual boost::any visit" + clas + base_class + "(std::shared_ptr<Environment> env, std::shared_ptr<const " + clas + "> expr) const = 0;\n"
    code += "\t};\n\n"

    # generate base class
    code += "\tclass " + base_class + "\n\t"
    code += "{\n\tpublic:\n\t\tvirtual ~" + base_class + "(void){};\n"
    code += "\t\tvirtual boost::any accept(std::shared_ptr<Environment> env, const " + base_class + "Visitor &visitor) const = 0;\n\t};\n\n"

    # generate class definitions
    for clas in classes:
        # generate class members
        code += "\tclass " + clas + " : public " + base_class + ", public std::enable_shared_from_this<" + clas + ">\n\t{\n\tpublic:\n"
        for memb in line_dict[clas]:
            if memb[0][:9] != "std::list":
                code += "\t\tstd::shared_ptr<const " + memb[0] + "> " + memb[1] + ";\n"
            else:
                code += "\t\tstd::shared_ptr<" + memb[0] + "> " + memb[1] + ";\n"
        code += "\n"
        
        # generate constructor
        code += "\t\t" + clas + "(" 
        code += ", ".join([ "std::shared_ptr<const " + "> ".join(memb) if memb[0][:9] != "std::list" else \
                            "std::shared_ptr<" + "> ".join(memb) for memb in line_dict[clas]]) 
        code += ")\n\t\t\t: "
        code += ", ".join([ memb[1] + "(" + memb[1] + ")" for memb in line_dict[clas]]) + "{};\n\n"

        # generate accept override
        code += "\t\tboost::any accept(std::shared_ptr<Environment> env, const " + base_class + "Visitor &visitor) const override\n\t\t{\n"
        code += "\t\t\treturn visitor.visit" + clas + base_class + "(env, shared_from_this());\n\t\t}\n\t};\n\n"
    
    code += "};\n#endif"

    return code

pth = "./src/ast/"
f_expr = "expression.hpp"
f_stmt = "statement.hpp"

expr = [ \
    "Assign   = Token name, Expression value",\
    "Binary   = Expression left, Token op, Expression right",\
    "Call     = Expression callee, Token paren, std::list<std::shared_ptr<Expression>> arguments",\
    "Get      = Expression obj, Token name",\
    "Grouping = Expression expression",\
    "Literal  = TokenType type, boost::any value",\
    "Logical  = Expression left, Token op, Expression right",\
    "Set      = Expression obj, Token name, Expression value",\
    "Super    = Token keyword, Token method",\
    "This     = Token keyword",\
    "Unary    = Token op, Expression right",\
    "Variable = Token name"\
    ]

stmt = [ \
    "Block      = std::list<std::shared_ptr<Statement>> statements",\
    "Class      = Token name, Variable superclass, std::list<std::shared_ptr<Function>> methods",\
    "ExpressionStatement = Expression expression",\
    "Function   = Token name, std::list<std::shared_ptr<Token>> params, std::list<std::shared_ptr<Statement>> body",\
    "If         = Expression condition, Statement thenBranch, Statement elseBranch",\
    "Print      = Expression expression",\
    "Return     = Token keyword, Expression value",\
    "Var        = Token name, Expression initializer",\
    "While      = Expression condition, Statement body"\
]

expr_dict = split_lines(expr)
expr_code = gen_code("Expression", expr_dict, ["environment/environment.hpp","scanner/token.hpp","memory","utility","boost/any.hpp"])
write_to_file(pth + f_expr, expr_code)

stmt_dict = split_lines(stmt)
stmt_code = gen_code("Statement", stmt_dict, ["environment/environment.hpp","scanner/token.hpp","ast/expression.hpp","memory","utility","boost/any.hpp"])
write_to_file(pth + f_stmt, stmt_code)